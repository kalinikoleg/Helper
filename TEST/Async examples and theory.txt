Основной поток, в котором выполняется задача, когда встречается с ассинхронным методом, например
выполнения запроса в бд, пул потоков помечает поток на ожидание, в этот момент менеджер забирает этот поток,
чтобы не тратить процессорное время на ожидание потока, когда метода из бд завершается,
ему дается любой свободный поток







код до первого await работает в  рабочем потоке ASP

Часто бывает, что выражение в строке, содержащей первый await, содержит еще один async-метод. 
Поскольку это выражение предшествует первому await, оно также выполняется в вызывающем потоке. 
Таким образом, вызывающий поток продолжает «углубляться» в код приложения, пока не встретит метод,
 действительно возвращающий объект Task. Это может быть метод, являющийся частью каркаса, 
 или метод, создающий задачу-марионетку с помощью TaskCompletionSource. Именно этот метод и 
 является источником асинхронности – все прочие async-методы просто распространяют асинхронность
 вверх по стеку вызовов. 
 
 
 1. основной поток 6
 2. углбуляется в первый асинхронной метод
 3. основной поток 6 первого асинхронного метод углубляется во второй асинхронный метод, который 
 вовзращает Task
 3. Первый асинхронный метод ждет выполнения таска, который начинает выполняться в фоновом потоке.
 В этот момент управление передалось в самый верх по стеку в потом номер 6
 4. Контекст основного потока заблокирвоался ждать выполнение таски в фоновом потоке
 5. в фоновом потоке таска выполнилась и вернула управление в поток, который запустил её выполнение и начал
 ждать завершения, а так  как тот поток является основным, он уже спит, в итоге получился deadlock
 
public async Task<ActionResult> Index()
	{
		var task = FirstDeep2Copy();

		var c = 10;

		Task.WaitAll(task);
		return View();
	}
	

	public async Task FirstDeep2Copy()
	{
		await LastDeep2Copy();

		// callback
		for (int i = 0; i < 3; i++)
		{
			var c = 10;
		}
	}

	public Task LastDeep2Copy()
	{
		return Task.Run(() =>
		{
			for (int i = 0; i < 2; i++)
			{
				var c = 1;
			}
		});
	}