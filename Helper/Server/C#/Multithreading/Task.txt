1.Следует  иметь  в  виду,  что  по  умолчанию  задача  исполняется  в  фоновом  потоке. 
Следовательно, при завершении создающего потока завершается и сама задача.
Основной поток должен быть задержан для того, чтобы выполнились все фоновые потоки

2. Первым из  них  является  исключение  ObjectDisposedException.  Оно  генерируется  в  том
случае,  если  задача  освобождена  посредством  вызова  метода  Dispose().  А  второе  ис?
ключение, AggregateException, генерируется в том случае, если задача сама генери?
рует  исключение  или  же  отменяется. 

3. Метод  Dispose()  реализуется  в  классе  Task,  освобождая  ресурсы,  используемые
этим классом. Как правило, ресурсы, связанные с классом  Task,  освобождаются авто?
матически  во  время  "сборки  мусора"  (или  по  завершении  программы).  Но  если  эти 
ресурсы требуется освободить еще раньше, то для этой цели служит метод Dispose().
Это особенно важно в тех программах, где создается большое число задач, оставляемых 
на произвол судьбы. 
Следует,  однако,  иметь  в  виду,  что  метод  Dispose() можно  вызывать  для  отдель?
ной  задачи  только  после  ее  завершения.  Следовательно,  для  выяснения  факта  завер?
шения  отдельной  задачи,  прежде  чем  вызывать  метод  Dispose(),  потребуется  неко?
торый  механизм,  например,  вызов  метода  Wait().  Именно  поэтому  так  важно  было
рассмотреть  метод  Wait(),  перед  тем  как  обсуждать  метод  Dispose().  Ели  же  по?
пытаться вызвать  Dispose()для все еще активной задачи, то будет сгенерировано ис?
ключение InvalidOperationException.

	public void MyTask()
	{
		Console.WriteLine("MyTask() запущен");
		for (int count = 0; count < 10; count++)
		{
			Thread.Sleep(500);
			Console.WriteLine("В методе MyTask(), подсчет равен " + count + "\t" + Thread.CurrentThread.ManagedThreadId);
		}
		Console.WriteLine("MyTask завершен ");
	}

	static void Main(string[] args)
	{
		Program application = new Program();

		Task task = new Task(application.MyTask);
		task.Start();  <-- выполняется асинхронно

		// Сохранить метод Main() активным до завершения метода MyTask().
		Console.WriteLine("############ main stream " + Thread.CurrentThread.ManagedThreadId);
		Task.WaitAll(task);
        task.Dispose();
	}

4.Применение класса TaskFactory для запуска задачи

Сначала в методе StartNew()автоматически  создается  экземпляр  объекта  
типа  Task  для  действия,  определяемого  параметром  action, а  затем 
планируется  запуск  задачи  на  исполнение.  Следовательно, 
необходимость в вызове метода Start()теперь отпадает.
	
 Task task = new Task(application.MyTask);
            task.Start();
<=>
Task task = Task.Factory.StartNew(application.MyTask);			
	
5. Создание продолжения задачи	
	
	
	
	
6. Задача получения  результата блокирует вызывающий код до тех пор, пока результат не будет 
вычислен.
	public static bool MyTask()
	{
		Console.WriteLine("MyTask ID " + Thread.CurrentThread.ManagedThreadId);
		Thread.Sleep(5000);
		return true;
	}

	public static int Sum(object v)
	{
		Console.WriteLine("Sum ID " + Thread.CurrentThread.ManagedThreadId);
		int x = (int)v;
		int sum = 0;
		for (; x > 0; x--)
		{
			sum = +x;
		}
		return sum;
	}

	static void Main(string[] args)
	{
		Program application = new Program();

		Task<bool> task = Task<bool>.Factory.StartNew(MyTask);
		Console.WriteLine("Результат после выполнения задачи MyTask: " + task.Result);

		Task<int> task2 = Task<int>.Factory.StartNew(Sum, 2);
		Console.WriteLine("Результат после выполнения задачи Sumlt: " + task2.Result);

		// Сохранить метод Main() активным до завершения метода MyTask().
		Console.WriteLine("############ main stream ID" + Thread.CurrentThread.ManagedThreadId);

		task.Dispose();
	}	
	
LinkedList
написать программу, которая будет 10 раз делать ++ переменной.и запцстить на 10 потоках

Выполн€ет задачу в новом потоке	не блокирую€ вызывающий поток, выполнитс€ хрен знает когда
Task.Factory.StartNew(() =>
{
	ProcessInData();
});


