Класс  Parallel  является  статическим,  и  в  нем  определены  методы  For(),
ForEach()и Invoke(). У каждого из этих методов имеются различные формы. В част­
ности, метод For()выполняет распараллеливаемый цикл for, а метод ForEach() —
распараллеливаемый  цикл  foreach,  и  оба  метода  поддерживают  параллелизм  дан­
ных.  А  метод  Invoke() поддерживает  параллельное  выполнение  двух  методов  иди
больше.

Тем не менее, если нужна более высокая степень контроля над выполняемыми зада¬
чами, следует отказаться от Parallel. Invoke () и напрямую работать с классом Task,

Метод  Invoke() сначала  инициирует  выполнение,  а  затем  ожидает  завершения
всех  передаваемых  ему  методов.  Это,  в  частности,  избавляет  от  необходимости  (да  и 
не  позволяет)  вызывать  метод  Wait().  Все  функции  параллельного  выполнения  метод
Wait()берет на себя. И хотя это не гарантирует, что методы будут действительно вы­
полняться  параллельно,  тем  не  менее,  именно  такое  их  выполнение  предполагается, 
если  система  поддерживает  несколько  процессоров.  Кроме  того,  отсутствует  возмож­
ность  указать  порядок  выполнения  методов  от  первого  и  до  последнего,  и  этот  поря­
док не может быть таким же, как и в списке аргументов.

Все работает в блокирующей манере(синхронно)

{
Parallel.Invoke(
	()=>AnyMethod,
	()=>AnyMethod
	);
}
{
	Parallel.For(0, 201, i =>
	{
		Get();
		Console.WriteLine(i+" ");
		//Console.WriteLine("Thread Id= {1}", Thread.CurrentThread.ManagedThreadId);
	});
}

{
string[] colors =
{
	"1. Red",
	"2. Green",
	"3. Blue",
	"4. Yellow",
	"5. White",
	"6. Black",
	"7. Violet",
	"8. Brown",
	"9. Orange",
	"10. Pink"
};

Parallel.ForEach(colors, color =>
{
	Console.WriteLine("{0}, Thread Id= {1}", color, Thread.CurrentThread.ManagedThreadId);
	Thread.Sleep(30);
});
}